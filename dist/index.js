var j=Object.create;var c=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty;var B=(e,t)=>{for(var r in t)c(e,r,{get:t[r],enumerable:!0})},N=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of U(t))!z.call(e,i)&&i!==r&&c(e,i,{get:()=>t[i],enumerable:!(n=T(t,i))||n.enumerable});return e};var W=(e,t,r)=>(r=e!=null?j(k(e)):{},N(t||!e||!e.__esModule?c(r,"default",{value:e,enumerable:!0}):r,e)),E=e=>N(c({},"__esModule",{value:!0}),e);var X={};B(X,{MatchedAnimationRule:()=>S,ParseCSS:()=>Q,cssParser:()=>M,resetData:()=>P});module.exports=E(X);function f(e){let t="";return e.type=="rule"&&(e=e,t=e.selector),t}var S=class{constructor(t,r){this.content=[];this.rule=t,this.intellisensePrefix=r}getMatchedContent(){let t={},r=this.content.map(i=>i.stringifiedNode),n=Object.fromEntries(r.entries());return t[this.intellisensePrefix]=()=>[n,this.rule.stringifiedNode],t}getMatchedValues(){let t={},r=f(this.rule.node).match(/\w+/g).join("-");return t[r]="",{values:t}}};var $=require("fs"),x=require("path"),w=W(require("postcss"));var R="[layer-parser]:";function g(e=1){let t=`
`;for(let r=0;r<e;r++)t+="	";return t+="- ",t}function m(e){console.log(`${R} ${e}`)}function u(e){console.warn(`${R} ${e}`)}function C(e){console.error(`${R} ${e}`)}var A=require("glob");function J(e,t={}){return e.type==="decl"&&(t[e.prop]=e.value),t}function y(e,t={},r=!0){if(e.type==="rule"){let n={};for(let i of e.nodes)i.type==="decl"?n=J(i,n):i.type==="rule"?n=y(i,n,r):i.type==="atrule"&&(n=O(i,n,r));if(r)t[e.selector]=n;else return n;return t}}function O(e,t={},r=!0){var n;if(e.type==="atrule"){let i={};if((n=e.nodes)!=null&&n[Symbol.iterator])for(let o of e.nodes)o.type==="decl"?i=J(o,i):o.type==="rule"?i=y(o,i,r):o.type==="atrule"&&(i=O(o,i,r));return t[`@${e.name} ${e.params}`]=i,t}}var d=new Map,p=new Map,h=new Map;function K(e,t){let r=f(e);if(d.has(r)){let n=p.get(r);if(n){let i=n==null?void 0:n.get(t.opts.from);i?n.set(t.opts.from,i+1):n.set(t.opts.from,1)}else p.set(r,new Map([[t.opts.from,1]]));return!1}return!0}function V(e,t){var n,i;if(((n=e.parent)==null?void 0:n.type)==="atrule"){let o=e.parent;if(o.params!=="components"&&o.params!=="utilities")return}else if(((i=e.parent)==null?void 0:i.type)!=="root")return;let r=f(e);if(K(e,t)){let o=y(e,{},!0);d.set(r,o)}}function q(){return()=>({Rule(e,{result:t}){V(e,t)}})}function H(e){var r,n;let t=i=>i!==!0&&i!==!1;e.directory==null&&(u("There was no directory provided. Defaulting to process.cwd()."),e.directory=process.cwd()),(r=e.debug)!=null||(e.debug=!1),t(e.debug)&&(u("Invalid configuration for debug. Defaulting to false."),e.debug=!1),(n=e.globPatterns)!=null||(e.globPatterns=["**/*.css"]),(e.animationPrefix==null||e.animationPrefix.trim().length==0)&&(e.animationPrefix="animate")}function P(){d.size==0&&m("Reset parsed components and utilities."),d.clear()}function M(e){if(e.globPatterns!=null&&e.globPatterns.length>0){for(let s of e.globPatterns)if(s.startsWith("/**"))return C(`
					User attempted to glob their entire computer using: ${s}.
					This would result in a serious performance problem, and thus parsing has been skipped.
				`),{utilities:[]}}H(e),p.clear(),h.clear();let t=(0,x.resolve)(e.directory),r=[];r=(0,A.globSync)(e.globPatterns,{cwd:t}),e.debug&&(m(`Searched directories: ${t}`),m(`Found: ${r.join("	")}`));let n={postcssPlugin:"layer-parser",prepare:q()},i=[],o=(0,w.default)([n]),L=(s,a)=>{let l=(0,$.readFileSync)(a,"utf8");o.process(l,{from:s,to:s}).then()};for(let s of r){if(!s.endsWith(".css")){i.push(s);continue}let a=(0,x.resolve)(t,s);L(s,a)}if(i.length>0&&u(`Globbing resulted in files that did not end in .css:
	${i.join(g())}`),h.size>0){let s=`The target directory: ${e.directory} had ${h.size} unlayered css rules not parsed:`;if(e.debug)for(let[a,l]of h)s+=`
	${a}`,s+=`
		- `,s+=Array.from(l.values()).join(g(2));u(s)}if(p.size>0){let s="",a=0;for(let[F,D]of p){s+=`
	${F}`;for(let[I,b]of D)s+=`${g(2)}${I} - ${b}`,a+=b}let l=`Found ${a} rules with selectors that were already used.
			Note, this only discovers root-level (not nested) duplicates that would be added based on the configuration.`;e.debug&&(l+=s),u(l)}return{utilities:Array.from(d.values())}}function Q(e){return({addUtilities:t})=>{P();let r=M(e);for(let n of r.utilities)t(n)}}0&&(module.exports={MatchedAnimationRule,ParseCSS,cssParser,resetData});
